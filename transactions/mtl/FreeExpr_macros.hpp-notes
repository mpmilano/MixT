#pragma once

#define $(x...) [&](){return (x);}

/*
issue with new design: when do we run the lambda?  We can run it on every execution of the loop, that's fine, but the 
enclosing free_expr needs to decide whether to run the lambda during the causal phase or the strong phase of execution.
we can't inspect the types inside the lambda; this isn't a problem for info-flow, because the deref'd-binding will
already drop the level down to the point we'd need it anyway, but it's a problem for the splitting semantics.

Why not both? run it in a try {...} during both strong and causal, and let it abort if that doesn't work out.

so: separate cache + const store during run, if we don't get a value out at the end then whatever, 

let's say we want to insert a strong-handle into a causal store. 

what we want to have happen is that everything runs strong, gets cached, then runs causal, gets cached, 
and then finally actually executes.



new idea: expressions in free_expr register themselves for ... nevermind, this isn't going to work easily.
PUNT!

*/
