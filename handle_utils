#pragma once


//METAFUNCTIONS GALORE!
namespace backend {

	template<bool b>
	struct neg : std::integral_constant<bool, !b> {};
	
	template <typename C>
	static constexpr std::integral_constant<bool,true> is_not_handle_f(C*)
	{return std::integral_constant<bool,true>();}
	
	template < Client_Id cid, Level L, HandleAccess HA, typename T>
	static constexpr std::integral_constant<bool,false> is_not_handle_f(DataStore::Handle<cid, L,HA,T>*)
	{return std::integral_constant<bool,false>();}
	
	template<typename T>
	struct is_not_handle : decltype( is_not_handle_f ( (typename std::decay<T>::type*) nullptr) ) {};
	
	template<typename T>
	struct is_handle : neg<is_not_handle<typename std::decay<T>::type>::value> {};
	

	template <typename C>
	static constexpr std::integral_constant<bool,true> handle_no_read_f(C*)
	{return std::integral_constant<bool,true>();}
	
	template < Client_Id cid, Level L, HandleAccess HA, typename T>
	static constexpr std::integral_constant<bool,!canRead(HA)> handle_no_read_f(DataStore::Handle<cid, L,HA,T>*)
	{return std::integral_constant<bool,!canRead(HA)>();}

	template<typename T>
	struct handle_no_read : decltype( handle_no_read_f ( (T*) nullptr) ) {};

	template<typename T>
	struct handle_read : neg<handle_no_read<T>::value> {};

	template < Client_Id cid, Level L, HandleAccess HA, typename T>
	static constexpr std::integral_constant<Level,L>
	handle_level_f (DataStore::Handle<cid, L,HA,T>*)
	{return std::integral_constant<Level,L>();}

	template<typename T>
	struct handle_level : decltype( handle_level_f ( (T*) nullptr) ) {
		static_assert(is_handle<T>::value, "Not a handle!");
	};
	
	template <typename C>
	static constexpr std::integral_constant<bool,true> handle_no_write_f(C*)
	{return std::integral_constant<bool,true>();}
	
	template < Client_Id cid, Level L, HandleAccess HA, typename T>
	static constexpr std::integral_constant<bool,!canWrite(HA)> handle_no_write_f(DataStore::Handle<cid, L,HA,T>*)
	{return std::integral_constant<bool,!canWrite(HA)>();}
	
	template<typename T>
	struct handle_no_write : decltype( handle_no_write_f ( (T*) nullptr) ) {};
	
	template<typename T>
	struct handle_write : neg<handle_no_write<T>::value> {};

	template<typename... Args>
	struct all_handles : bool_const<! any<is_not_handle, pack<Args...> >::value > {};

	template<typename... Args>
	struct all_handles_read : bool_const<! any <handle_no_read, pack<Args...> >::value > {};

	template<typename... Args>
	struct all_handles_write : bool_const <! any <handle_no_write, pack<Args...> >::value> {};
	
	template<typename... Args>
	struct exists_write_handle : any <handle_write, pack<Args...> > {};
	
	template<typename... Args>
	struct exists_read_handle : any <handle_read, pack<Args...> > {};

	template <typename C>
	static constexpr auto handle_rw_f(C*)
	{return std::integral_constant<bool,false>();}
	
	template < Client_Id cid, Level L, typename T>
	static constexpr auto handle_rw_f(DataStore::Handle<cid, L,HandleAccess::all,T>*)
	{return std::integral_constant<bool,true>();}
	
	template<typename T>
	struct handle_rw : decltype( handle_rw_f ( (T*) nullptr) ) {};

	template<typename... Args>
	struct exists_rw_handle : any <handle_rw, pack<Args...> > {};
	
	
	template<backend::Client_Id id, backend::Level l, backend::HandleAccess ha, typename T>
	T extract_type_f(const backend::DataStore::Handle<id,l,ha,T>*);
	
	template<typename T>
	struct extract_type {
		typedef decltype(extract_type_f((typename std::decay<T>::type*) nullptr)) type;
	};


}
