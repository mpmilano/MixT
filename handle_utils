#pragma once


//METAFUNCTIONS GALORE!
namespace backend {

	template<bool b>
	struct neg : std::integral_constant<bool, !b> {};
	
	template <typename C>
	static constexpr std::integral_constant<bool,true> is_not_handle_f(C*)
	{return std::integral_constant<bool,true>();}
	
	template < Client_Id cid, Level L, HandleAccess HA, typename T>
	static constexpr std::integral_constant<bool,false> is_not_handle_f(DataStore::Handle<cid, L,HA,T>*)
	{return std::integral_constant<bool,false>();}
	
	template<typename T>
	struct is_not_handle : decltype( is_not_handle_f ( (T*) nullptr) ) {};
	
	template<typename T>
	struct is_handle : neg<is_not_handle<T>::value> {};
	

	template <typename C>
	static constexpr std::integral_constant<bool,true> handle_no_read_f(C*)
	{return std::integral_constant<bool,true>();}
	
	template < Client_Id cid, Level L, HandleAccess HA, typename T>
	static constexpr std::integral_constant<bool,!canRead(HA)> handle_no_read_f(DataStore::Handle<cid, L,HA,T>*)
	{return std::integral_constant<bool,!canRead(HA)>();}

	template<typename T>
	struct handle_no_read : decltype( handle_no_read_f ( (T*) nullptr) ) {};

	template<typename T>
	struct handle_read : neg<handle_no_read<T>::value> {};

	
	template <typename C>
	static constexpr std::integral_constant<bool,true> handle_no_write_f(C*)
	{return std::integral_constant<bool,true>();}
	
	template < Client_Id cid, Level L, HandleAccess HA, typename T>
	static constexpr std::integral_constant<bool,!canWrite(HA)> handle_no_write_f(DataStore::Handle<cid, L,HA,T>*)
	{return std::integral_constant<bool,!canWrite(HA)>();}
	
	template<typename T>
	struct handle_no_write : decltype( handle_no_write_f ( (T*) nullptr) ) {};
	
	template<typename T>
	struct handle_write : neg<handle_no_write<T>::value> {};

	template<typename... Args>
	struct all_handles : bool_const<! any<is_not_handle, pack<Args...> >::value > {};

	template<typename... Args>
	struct all_handles_read : bool_const<! any <handle_no_read, pack<Args...> >::value > {};

	template<typename... Args>
	struct all_handles_write : bool_const <! any <handle_no_write, pack<Args...> >::value> {};
	
	template<typename... Args>
	struct exists_write_handle : any <handle_write, pack<Args...> > {};
	
	template<typename... Args>
	struct exists_read_handle : any <handle_read, pack<Args...> > {};

	template <typename C>
	static constexpr std::integral_constant<bool,false> handle_requires_sync_f(C*)
	{return std::integral_constant<bool,false>();}
	
	template < Client_Id cid, HandleAccess HA, typename T>
	static constexpr std::integral_constant<bool,true> handle_requires_sync_f(DataStore::Handle<cid,Level::strong,HA,T>*)
	{return std::integral_constant<bool,true>();}

	template<typename T>
	struct handle_requires_sync : decltype( handle_requires_sync_f ( (T*) nullptr) ) {};

	template<typename... Args>
	struct any_required_sync : any <handle_requires_sync, pack<Args...> > {};

	template <typename C>
	static constexpr auto handle_rw_f(C*)
	{return std::integral_constant<bool,false>();}
	
	template < Client_Id cid, Level L, typename T>
	static constexpr auto handle_rw_f(DataStore::Handle<cid, L,HandleAccess::all,T>*)
	{return std::integral_constant<bool,true>();}
	
	template<typename T>
	struct handle_rw : decltype( handle_rw_f ( (T*) nullptr) ) {};

	template<typename... Args>
	struct exists_rw_handle : any <handle_rw, pack<Args...> > {};

}
